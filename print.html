<!DOCTYPE HTML>
<html lang="ru" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RISC-V Crypto: Исследование и реализация</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html">Введение</a></li><li class="chapter-item expanded "><a href="docs.html">Руководство Пользователя</a></li><li class="chapter-item expanded affix "><li class="part-title">Материалы</li><li class="chapter-item expanded "><a href="materials/links.html">Полезные ссылки</a></li><li class="chapter-item expanded "><a href="materials/reviews/intro.html">Обзоры ядер</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="materials/reviews/CV32E40P/CV32E40P.html">CV32E40P</a></li><li class="chapter-item expanded "><a href="materials/reviews/DarkRISCV/DarkRISCV.html">DarkRISCV</a></li><li class="chapter-item expanded "><a href="materials/reviews/CVA6/CVA6.html">CVA6</a></li><li class="chapter-item expanded "><a href="materials/reviews/PicoRV32/PicoRV32.html">PicoRV32</a></li></ol></li><li class="chapter-item expanded "><a href="materials/programing/intro.html">Программирование</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="materials/programing/compiler/intro.html">Компилятор</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="materials/programing/compiler/inline_asm.html">Ассемблерные вставки</a></li><li class="chapter-item expanded "><a href="materials/programing/compiler/modding.html">Модифицирование компилятора</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="materials/cosim/intro.html">Косимуляция</a></li><li class="chapter-item expanded affix "><li class="part-title">Отчёты</li><li class="chapter-item expanded "><a href="reports/2023-10-30/report.html">30.10.2023 =&gt; 5.11.2023</a></li><li class="chapter-item expanded "><a href="reports/2023-11-13/report.html">13.11.2023 =&gt; 19.11.2023</a></li><li class="chapter-item expanded "><a href="reports/2023-11-20/report.html">20.11.2023 =&gt; 26.11.2023</a></li><li class="chapter-item expanded "><a href="reports/2023-11-27/report.html">27.11.2023 =&gt; 3.12.2023</a></li><li class="chapter-item expanded "><a href="reports/2023-12-11/report.html">11.12.2023 =&gt; 17.12.2023</a></li><li class="chapter-item expanded "><a href="reports/2024-01-08/report.html">08.01.2024 =&gt; 14.01.2024</a></li><li class="chapter-item expanded "><a href="reports/2024-01-22/report.html">22.01.2024 =&gt; 28.01.2024</a></li><li class="chapter-item expanded "><a href="reports/2024-04-01/report.html">01.04.2024 =&gt; 14.04.2024</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RISC-V Crypto: Исследование и реализация</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Введение"><a class="header" href="#Введение">Введение</a></h1>
<h2 id="Что-это"><a class="header" href="#Что-это">Что это?</a></h2>
<p>Стоит начать с того, что мы делаем нашу выпускную квалификациюнную работу
бакалавриата, в данный момент интересует устройство и проектирование
аппаратуры, поэтому выбор темы пал на расширение какого-то ядра RISC-V
дополнительным функционалом, в данном случае инструкциями криптографии.</p>
<h2 id="Формальное-описание"><a class="header" href="#Формальное-описание">Формальное описание</a></h2>
<p><strong>Реализация криптографического расширения архитектуры RISC-V</strong></p>
<p><strong>Realization of cryptographic extension of RISC-V architecture</strong></p>
<p>RISC-V — перспективная и стремительно развивающаяся процессорная архитектура,
доступная для свободного использования. Кроме базового набора инструкций,
существует возможность для расширения под специфические задачи. В рамках ВКР
надо будет реализовать криптографическое расширение для базовой реализации
RISC-V ядра. В процессе выполнения работы студентам потребуется изучить
архитектуру RISC-V, базовые криптографические алгоритмы и реализовать
дополнительный набор команд для процессорного ядра на языке Verilog, содержащий
не менее 20 инструкций. Также нужно будет провести сравнительное тестирование
на бенчмарке CoreMark и других собственных бенчмарках.</p>
<h2 id="Команда"><a class="header" href="#Команда">Команда</a></h2>
<ul>
<li><strong>Руководитель:</strong> Романов Александр Юрьевич</li>
<li><strong>Студенты:</strong>
<ul>
<li>Фролов Кирилл Дмитриевич</li>
<li>Мирошниченко Лев Игоревич</li>
</ul>
</li>
<li><strong>Наставники:</strong>
<ul>
<li>Американов Александр Александрович</li>
<li>Зунин Владимир Викторович</li>
<li>Лежнёв Евгений Владимирович</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Документация"><a class="header" href="#Документация">Документация</a></h1>
<p><strong>Авторы</strong>: Фролов Кирилл, Мирошниченко Лев</p>
<h2 id="Структура-репозитория"><a class="header" href="#Структура-репозитория">Структура репозитория</a></h2>
<p>В ветке "rv32i" представлена версия ядра schoolRISCV, поддерживающее базовый набор инструкций RV32I, а в ветке "master" представлена версия расширенного ядра schoolRISCV с добавленным криптографическим модулем.</p>
<h3 id="Содержимое-репозитория"><a class="header" href="#Содержимое-репозитория">Содержимое репозитория:</a></h3>
<ul>
<li><strong>board</strong> - папки с заготовленными проектами Quartus для различных плат ПЛИС (название папки соответсвует названию платы);</li>
<li><strong>doc</strong> - документы со спецификацией архитектуры RISCV;</li>
<li><strong>install</strong> - различные инструменты для работы с проектом, которые можно установить;</li>
<li><strong>materials</strong> - результаты моделирования, портирование, ресурсного и временного анализа базового и расширенного ядер schoolRISCV с программами, выполняющими криптографические операции;</li>
<li><strong>program</strong> - папки с разработанными программами, каждая папка называется аналогично содержащейся в ней программе (в каждой папке есть файл main.S или *.asm с текстом программы на языке ассемблер и файл program.hex с программой, представленной в машинном коде);
<ul>
<li>в ветке "master" отдельно представлена папка "native_crypto" с программами, использующими криптографические инструкции;</li>
<li>в ветке "rv32i" отдельно представлена пака "prog_crypto" с программами, выполняющими криптографические операции на базовых инструкциях набора RV32I;</li>
</ul>
</li>
<li><strong>src</strong> - файлы с описанием ядра на языке Verilog;</li>
<li><strong>submodules</strong> - файлы с описанием криптографического модуля;</li>
<li><strong>testbench</strong> - файлы с описанием тестбенчей, разработанных для моделирования работы ядер</li>
</ul>
<h2 id="Разработка-программ"><a class="header" href="#Разработка-программ">Разработка программ</a></h2>
<p>Для разработки программ потребуется использовать ассемблер RARS (<code>rars1_4.jar</code>
находится в директории <code>program/common</code>, для запуска использовать команду <code>java -jar rars1_4.jar</code>).</p>
<p>Интерфейс RARS выглядит следующим образом:</p>
<p><img src="./docs_img/rars_interface.png" alt="RARS Interface" /></p>
<p>Рассмотрим ассемблирование программы на простом примере, для начала необходимо
разработать программу в текстовом редакторе:</p>
<p><img src="./docs_img/rars_program.png" alt="RARS Program" /></p>
<p>Для ассемблирования необходимо нажать кнопку "Assemble the current file":</p>
<p><img src="./docs_img/rars_assemble.png" alt="RARS Assemble" /></p>
<p>В результате программа перейдёт в следующее состояние:</p>
<p><img src="./docs_img/rars_debugger.png" alt="RARS Debugger" /></p>
<p>Также программу можно просимулировать и отладить непосредственно в RARS, для
этого необходимо нажать кнопку "Run" справа от кнопки "Assemble the current
file":</p>
<p><img src="./docs_img/rars_simulate.png" alt="RARS Simulate" /></p>
<p>Для дампа программы в шеснадцатеричный формат необходимо нажать кнопку "Dump
machine code":</p>
<p><img src="./docs_img/rars_dump.png" alt="RARS Dump" /></p>
<p>И выбрать формат "Hexadecimal Text":</p>
<p><img src="./docs_img/rars_hexcode.png" alt="RARS Hexcode" /></p>
<div class="warning">
Важно:
<p>RARS не умеет обрабатывать инструкции криптографического расширения, для их
использования нобходимо вставить инструкцию на машинном коде в результирующий
файл дампа.</p>
</div>
<h2 id="Симуляция-ядра"><a class="header" href="#Симуляция-ядра">Симуляция ядра</a></h2>
<p>Для симуляции ядра потребуется программа в формате <code>.hex</code>, её получение подробно
описано в разделе <code>Разработка программ</code>.</p>
<p>Создайте отдельную папку для Вашей программы в директории <code>program/</code> и
скопируйте в неё файл <code>Makefile</code> из любой другой директории в <code>program/</code>. Далее
добавьте в новую директорию прогрумму в формате <code>.hex</code>.</p>
<p>Для старта симуляции перейдите в созданную директорию и введите команду <code>make icarus</code>. Результат будет, примерно, следующий (симуляция описывает процесс для
каждой инструкции):
<img src="./docs_img/sim_result.png" alt="Sim Result" /></p>
<h2 id="Синтез-ядра"><a class="header" href="#Синтез-ядра">Синтез ядра</a></h2>
<h3 id="Для-произведения-синтеза-ядра-необходимо"><a class="header" href="#Для-произведения-синтеза-ядра-необходимо">Для произведения синтеза ядра необходимо:</a></h3>
<ol>
<li>Предварительно установить приложение Quartus;</li>
<li>Перейти в папку board, а затем в папку с названием платы ПЛИС, на которую будет производится портирование;</li>
<li>Переименовать содержащиеся в папке файлы путем удаления символа "_" из расширения файла (Пример: <code>*.qpf_</code> -&gt; <code>*.qpf</code>);</li>
<li>Запустить программу Quatus и в верхнем меню программы нажать кнопку "File" и из выпавшего меню нажать кнопку "Open Project", после чего выбрать файл <code>*.qpf</code> в папке из пункта 2;</li>
</ol>
<p><img src="https://github.com/leventium/bachelor-work/assets/139256075/db2ffaf5-d772-496a-b28f-5cc53af29b63" alt="Меню открытия проекта в Quartus" /></p>
<ol start="5">
<li>Убедиться, что все файлы из папки "src" добавлены в проекта, в обратном случае добавить все недостающие файлы путем нажатия кнопки "File" и нажатия кнопки "Open" из выпавшего меню. При выборе файлов в проводнике установить галочку в поле "Add file to current project";</li>
</ol>
<p><img src="https://github.com/leventium/bachelor-work/assets/139256075/e3308ccb-bad2-49ff-b407-6f60c259a238" alt="Меню добавления файлов в проект Quartus" /></p>
<p><img src="https://github.com/leventium/bachelor-work/assets/139256075/f2a32739-4cad-45c7-8c07-3a61fa41ace6" alt="Активное поле &quot;Add file to current project&quot;" /></p>
<ol start="6">
<li>Выбрать программу, которую необходимо выполнить на ядре из папки "program" и скопировать файл <code>program.hex</code> в папку с проектом из пункта 2;</li>
<li>Выполнить синтез проекта, нажав кнопку "Start Compilation" в панели инструментов Quartus;</li>
</ol>
<p><img src="https://github.com/leventium/bachelor-work/assets/139256075/2a38df7e-b03d-4df6-9244-91acc33b0a93" alt="Кнопка запуска синтеза" /></p>
<ol start="8">
<li>Дождаться завершения синтеза проекта;</li>
<li>В окне "Compilation Report" можно ознакомиться с результатами синтеза проекта и с числом использованный ресурсов.</li>
</ol>
<p><img src="https://github.com/leventium/bachelor-work/assets/139256075/051a0d57-b0fe-4f2e-9a11-1c27495ad70e" alt="Compilation Report" /></p>
<h3 id="Для-получения-значения-максимальной-частоты-на-которой-способно-работать-ядро-необходимо"><a class="header" href="#Для-получения-значения-максимальной-частоты-на-которой-способно-работать-ядро-необходимо">Для получения значения максимальной частоты, на которой способно работать ядро, необходимо:</a></h3>
<ol>
<li>Нажать из верхнего меню кнопку "Tools" и из выпавшего меню нажать кнопку "TimeQuest Timing Analyzer";</li>
</ol>
<p><img src="https://github.com/leventium/bachelor-work/assets/139256075/9f892dd1-0160-4683-b849-7a687bf1b659" alt="Меню открытия временного анализа" /></p>
<ol start="2">
<li>В открывшемся окне в нижнем левом меню "Tasks" нажать кнопку "Report Fmax Summary";</li>
</ol>
<p><img src="https://github.com/leventium/bachelor-work/assets/139256075/3a725ec9-071d-46aa-a306-76425a860dab" alt="Меню открытия с расчетом максимальной частоты" /></p>
<ol start="3">
<li>Ознакомиться с максимальной частотой, на которой способно работать ядро.</li>
</ol>
<p><img src="https://github.com/leventium/bachelor-work/assets/139256075/c800ff6e-dc57-4948-ad57-ffee9c73dd01" alt="Результат расчета максимальной частоты" /></p>
<h3 id="Для-загрузки-проекта-на-плату-ПЛИС-необходимо"><a class="header" href="#Для-загрузки-проекта-на-плату-ПЛИС-необходимо">Для загрузки проекта на плату ПЛИС необходимо:</a></h3>
<ol>
<li>Предварительно подключить плату ПЛИС к компьютеру;</li>
<li>Нажать кнопку "Programmer" в панели инструментов Quartus;</li>
</ol>
<p><img src="https://github.com/leventium/bachelor-work/assets/139256075/bc44675b-6529-4c0c-a7b0-b1f008e02ef5" alt="Кнопка &quot;Programmer&quot;" /></p>
<ol start="3">
<li>Нажать кнопку "Hardware Setup" и выбрать устройство для программирования;</li>
</ol>
<p><img src="https://github.com/leventium/bachelor-work/assets/139256075/303e4bf0-416d-4f84-ab61-6cc391b0fc95" alt="Кнопку &quot;Hardware Setup&quot;" /></p>
<ol start="4">
<li>Нажать кнопку "Start".</li>
</ol>
<h2 id="Описание-базового-ядра"><a class="header" href="#Описание-базового-ядра">Описание базового ядра</a></h2>
<h3 id="Схема-описание-ядра-schoolriscv-поддерживающего-базовый-набор-инструкций-rv32i"><a class="header" href="#Схема-описание-ядра-schoolriscv-поддерживающего-базовый-набор-инструкций-rv32i">Схема-описание ядра schoolRISCV, поддерживающего базовый набор инструкций RV32I:</a></h3>
<p><img src="https://github.com/leventium/bachelor-work/assets/139256075/affaa990-ec17-4371-9420-70103b902f8d" alt="Схема-описание базового ядра" /></p>
<h3 id="Основные-компоненты-ядра"><a class="header" href="#Основные-компоненты-ядра">Основные компоненты ядра:</a></h3>
<ul>
<li><strong>Instruction Memory</strong> - ROM-память, хранящая список испольняемых инструкций, представленных в машинном коде;</li>
<li><strong>PC (Program Counter)</strong> - программный счетчик, указывает на инструкцию, испольняемую на данной итерации;</li>
<li><strong>Decode</strong> - блок, декодирующий значение из Instruction Memory на основе спецификации RV32I;</li>
<li><strong>Register File</strong> - память, хранящая значения регистров;
<ul>
<li><strong>A1, A2, A3</strong> - адресные порты;</li>
<li><strong>RD1, RD2</strong> - порты чтения данных;</li>
<li><strong>WD3</strong> - порт записи данных;</li>
<li><strong>WE3</strong> - порт разрешения записи;</li>
</ul>
</li>
<li><strong>ALU</strong> - блок, выполняющий арифметические и логические операции над входными операндами;</li>
<li><strong>Data Memory</strong> - память данных;
<ul>
<li><strong>A</strong> - адресный порт;</li>
<li><strong>RD</strong> - порт чтения данных;</li>
<li><strong>WD</strong> - порт записи данных;</li>
<li><strong>WE</strong> - порт разрешения записи;</li>
<li><strong>op_byte, op_half, op_word</strong> - порты управления режимами чтения, записи (байт, полуслово, слово);</li>
</ul>
</li>
<li><strong>Control Unit</strong> - управляющий блок, идентифицирует инструкции и в зависимости от исполняемой инструкции изменяет значения управляющих сигналов мультиплексоров, памяти регистров и памяти данных;</li>
<li><strong>Логика перехода в нижней части схемы</strong> - состоит из 2-х мультиплексоров и сумматора, рассчитывает следующее значение Program Counter.</li>
</ul>
<h2 id="Описание-расширенного-ядра"><a class="header" href="#Описание-расширенного-ядра">Описание расширенного ядра</a></h2>
<h3 id="Схема-описание-расширенного-ядра"><a class="header" href="#Схема-описание-расширенного-ядра">Схема-описание расширенного ядра:</a></h3>
<p><img src="./docs_img/core_w_crypto.png" alt="Core Extended" /></p>
<h3 id="Описание-изменений"><a class="header" href="#Описание-изменений">Описание изменений:</a></h3>
<ul>
<li><strong>Crypto Module</strong> - криптографический модуль на которое отправляются вычисления специальных инструкций
<ul>
<li><strong>crMode</strong> - шина выбора криптографической операции</li>
<li><strong>crRes</strong> - результат выполнения операции</li>
</ul>
</li>
<li><strong>Control Unit</strong>
<ul>
<li><strong>pc_hold</strong> - управляющий сигнал для программного счётчика, приостонавливающий его работу</li>
</ul>
</li>
</ul>
<div class="warning">
Управляющий модуль больше не является только комбинационной логикой, был добавлен конечный автомат для корректирования работы схемы.
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Полезные-ссылки"><a class="header" href="#Полезные-ссылки">Полезные ссылки</a></h1>
<h2 id="Статьи"><a class="header" href="#Статьи">Статьи</a></h2>
<ul>
<li><a href="https://www.researchgate.net/publication/361843646_Design_of_an_Integrated_Cryptographic_SoC_Architecture_for_Resource-Constrained_Devices">Реализация криптографического расширения на PicoRV32</a></li>
</ul>
<h2 id="Криптография"><a class="header" href="#Криптография">Криптография</a></h2>
<h3 id="aes"><a class="header" href="#aes">AES</a></h3>
<p><strong>Материалы:</strong></p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a></li>
</ul>
<p><strong>Реализации:</strong></p>
<ul>
<li><a href="https://opencores.org/projects/tiny_aes">https://opencores.org/projects/tiny_aes</a></li>
<li><a href="https://github.com/kokke/tiny-AES-c">https://github.com/kokke/tiny-AES-c</a></li>
</ul>
<h3 id="sha"><a class="header" href="#sha">SHA</a></h3>
<p><strong>Материалы:</strong></p>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/SHA-2">https://ru.wikipedia.org/wiki/SHA-2</a></li>
</ul>
<p><strong>Реализации:</strong></p>
<ul>
<li><a href="https://opencores.org/projects/sha_core">https://opencores.org/projects/sha_core</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Обзоры-ядер"><a class="header" href="#Обзоры-ядер">Обзоры ядер</a></h1>
<h2 id="Мотивация-главных-героев"><a class="header" href="#Мотивация-главных-героев">Мотивация главных героев</a></h2>
<p>Не без чужой помощи<sup class="footnote-reference"><a href="#help">1</a></sup> поняли, что достаточно подробно ядра мы не
рассмотрели и сейчас наш выбор основывается на "нам понравилось", будем это
исправлять. Цель -- рассмотреть каждый процессор из списка как можно подробнее.</p>
<h2 id="Ядра-для-обзора"><a class="header" href="#Ядра-для-обзора">Ядра для обзора</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Название</th><th>Репозиторий</th></tr></thead><tbody>
<tr><td>CV32E40P</td><td><a href="https://github.com/openhwgroup/cv32e40p">https://github.com/openhwgroup/cv32e40p</a></td></tr>
<tr><td>Ibex (formerly Zero-riscy)</td><td><a href="https://github.com/lowRISC/ibex">https://github.com/lowRISC/ibex</a></td></tr>
<tr><td>CVA6</td><td><a href="https://github.com/openhwgroup/cva6">https://github.com/openhwgroup/cva6</a></td></tr>
<tr><td>OPenV/mriscv</td><td><a href="https://github.com/onchipuis/mriscv">https://github.com/onchipuis/mriscv</a></td></tr>
<tr><td>Roa Logic RV12</td><td><a href="https://github.com/roalogic/RV12">https://github.com/roalogic/RV12</a></td></tr>
<tr><td>SCR1</td><td><a href="https://github.com/syntacore/scr1">https://github.com/syntacore/scr1</a></td></tr>
<tr><td>Hummingbird E200</td><td><a href="https://github.com/SI-RISCV/e200_opensource">https://github.com/SI-RISCV/e200_opensource</a></td></tr>
<tr><td>PicoRV32</td><td><a href="https://github.com/cliffordwolf/picorv32">https://github.com/cliffordwolf/picorv32</a></td></tr>
<tr><td>SERV</td><td><a href="https://github.com/olofk/serv">https://github.com/olofk/serv</a></td></tr>
<tr><td>SweRV EH1</td><td><a href="https://github.com/chipsalliance/Cores-SweRV">https://github.com/chipsalliance/Cores-SweRV</a></td></tr>
<tr><td>SweRV EL2</td><td><a href="https://github.com/chipsalliance/Cores-SweRV-EL2">https://github.com/chipsalliance/Cores-SweRV-EL2</a></td></tr>
<tr><td>SweRV EH2</td><td><a href="https://github.com/chipsalliance/Cores-SweRV-EH2">https://github.com/chipsalliance/Cores-SweRV-EH2</a></td></tr>
<tr><td>biRISC-V</td><td><a href="https://github.com/ultraembedded/biriscv">https://github.com/ultraembedded/biriscv</a></td></tr>
<tr><td>DarkRISCV</td><td><a href="https://github.com/darklife/darkriscv">https://github.com/darklife/darkriscv</a></td></tr>
<tr><td>SSRV</td><td><a href="https://github.com/risclite/SuperScalar-RISCV-CPU">https://github.com/risclite/SuperScalar-RISCV-CPU</a></td></tr>
<tr><td>Tinyriscv</td><td><a href="https://github.com/liangkangnan/tinyriscv">https://github.com/liangkangnan/tinyriscv</a></td></tr>
<tr><td>RSD</td><td><a href="https://github.com/rsd-devel/rsd">https://github.com/rsd-devel/rsd</a></td></tr>
<tr><td>Kronos</td><td><a href="https://github.com/SonalPinto/kronos">https://github.com/SonalPinto/kronos</a></td></tr>
<tr><td>Steel</td><td><a href="https://github.com/rafaelcalcada/steel-core">https://github.com/rafaelcalcada/steel-core</a></td></tr>
</tbody></table>
</div>
<h2 id="Формат-обзоров"><a class="header" href="#Формат-обзоров">Формат обзоров</a></h2>
<p>Формат будет состоять из положительных и негативных сторон каждого ядра, а
также решения и выводов которые мы сделали после его изучения.</p>
<hr />
<div class="footnote-definition" id="help"><sup class="footnote-definition-label">1</sup>
<p>Спасибо, Александр Александрович!</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cv32e40p"><a class="header" href="#cv32e40p">CV32E40P</a></h1>
<ul>
<li><a href="https://github.com/openhwgroup/cv32e40p">GitHub</a></li>
<li><a href="https://docs.openhwgroup.org/projects/cv32e40p-user-manual/en/latest/">Docs</a></li>
</ul>
<h2 id="Введение-1"><a class="header" href="#Введение-1">Введение</a></h2>
<p>Уменьшенное (по сравнению с CVA6) 32-битное ядро RISC-V с насыщенным
функционалом и документацией, которое продолжает развиваться.</p>
<p>CV32E40P - это софт-процессорное ядро написанное OpenHWGroup на SystemVerilog,
обладает 32-битной архитектурой. Общая схема представлена ниже:</p>
<p><img src="materials/reviews/CV32E40P/./CV32E40P_Block_Diagram.png" alt="CV32E40P Block Diagram" title="Блок-схема CV32E40P" /></p>
<p>Ядро реализует RV32I, а также следующие стандартные расширения:</p>
<div class="table-wrapper"><table><thead><tr><th>Название</th><th>Описание</th></tr></thead><tbody>
<tr><td><strong>C</strong></td><td>Расширение для сжатых инструкций</td></tr>
<tr><td><strong>M</strong></td><td>Расширения для целочисленного деления и умножения</td></tr>
<tr><td><strong>Zicntr</strong></td><td>Счётчики производительности</td></tr>
<tr><td><strong>Zicsr</strong></td><td>Инструкции для контроля и регистра статуса</td></tr>
<tr><td><strong>Zifencei</strong></td><td>Механизм получения инструкций</td></tr>
</tbody></table>
</div>
<p>Дополнительно могут быть подключены:</p>
<div class="table-wrapper"><table><thead><tr><th>Название</th><th>Описание</th></tr></thead><tbody>
<tr><td><strong>F</strong></td><td>Расширение для операций с вещественными числами (одинарной точности)</td></tr>
<tr><td><strong>Zfinx</strong></td><td>X регистры для расширения F</td></tr>
</tbody></table>
</div>
<p>Ядро имеет опциональные нестандартные расширения для работы с PULP (Parallel
Ultra-Low-Power):</p>
<div class="table-wrapper"><table><thead><tr><th>Название</th><th>Описание</th></tr></thead><tbody>
<tr><td><strong>Xcv</strong></td><td>CORE-V PULP ISA</td></tr>
<tr><td><strong>Xcvelw</strong></td><td>CORE-V PULP Cluster ISA</td></tr>
</tbody></table>
</div>
<h2 id="Заметки"><a class="header" href="#Заметки">Заметки</a></h2>
<p>CV32E40P не является системой на кристале, поэтому не имеет встроенной памяти
инструкций и памяти данных, во многом это может быть полезно и удобно, так как
процессор не навязывает конкретных реализация и даёт разработчику возможность
самостоятельно определить эти блоки.</p>
<p>Такое решение также может быть удобно в случае реализации косимуляции
процессора RISC-V, где инструкции будут подаваться на процессор с компьютера,
таким образом можно реализовать специфичный Instruction Memory, который будет
обращаться к компьютеру по UART и выдвать инструкцию словно сам их хранит.</p>
<h3 id="instruction-memory---описание"><a class="header" href="#instruction-memory---описание">Instruction Memory - описание</a></h3>
<p>Процессор даёт строгую спецификацию к пямяти инструкций и ожидает от неё
заданного поведения, далее будет описано, что мы смогли выяснить и реализовать.</p>
<p>Первое с чего стоит начать, описание входов и выходов, они приведены ниже с
указанием разрядности каждого:</p>
<ul>
<li><code>instr_addr_o[31:0]</code></li>
<li><code>instr_req_o</code></li>
<li><code>instr_gnt_i</code></li>
<li><code>instr_rvalid_i</code></li>
<li><code>instr_rdata_i[31:0]</code></li>
</ul>
<p><del>Интересно, что они придерживаются конвенции, где _o на конце обозначает
выходной сигнал, а _i входной, возможно, стоит взять на заметку</del></p>
<p><code>instr_addr_o</code> адрес запрашиваемой инструкции, выровнен по машинному слову,
добавить нечего.</p>
<p><code>instr_req_o</code> сигнал, обозначающий, что запрос всё ещё актуален, остаётся
истинным до тех пор, пока <code>instr_gnt_i</code> не будет истинным хотя бы один такт.</p>
<p><code>instr_gnt_i</code> обозначает, что принимающая сторона приняла запрос и процессор
может выдать следующий запрос.</p>
<p><code>instr_rdata_i</code> содержит запрошенные данные...</p>
<p><code>instr_rvalid_i</code> обозначает, что данные на выходе актуальны, должен оставаться
истинным не более чем на один такт для одного запроса.</p>
<p>Было замечено, что процессор не обязывает отвечать за один такт, это позволяет
производить более затратные операции во время запроса инструкций, например,
передача или получение данных извне.</p>
<p>Пример временной диаграмы обращения к памяти инструкций:</p>
<p><img src="materials/reviews/CV32E40P/./instr_mem_wave.png" alt="Instruction Memory Waveform" /></p>
<p>Также процессор имеет возможность работать с instruction memory по транзакциям,
пример такого поведения:</p>
<p><img src="materials/reviews/CV32E40P/./instr_mem_transaction.png" alt="Instruction Memory Transaction" /></p>
<h3 id="instruction-memory---реализация"><a class="header" href="#instruction-memory---реализация">Instruction Memory - реализация</a></h3>
<p>Для загрузки на плату нам потребуется реализовать память инструкций
самостоятельно, поэтому сделаем простейшую реализацию, которая будет выполнять
требования интерфейса, пример приведён ниже.</p>
<pre><code class="language-verilog">module inst_mem (
    input             clk,
    input      [31:0] addr,
    input             req_valid,
    output            accepted,
    output reg        rvalid,
    output reg [31:0] rdata
);
    reg [31:0] mem [255:0];
    assign accepted = 1'b1;

    always @(posedge clk) begin
        if (req_valid) begin
            rdata = mem[31:2];
            rvalid = 1'b1;
        end else begin
            rvalid = 1'b0;
        end
    end

endmodule
</code></pre>
<h3 id="Загрузка-на-плату"><a class="header" href="#Загрузка-на-плату">Загрузка на плату</a></h3>
<p>Для загрузки на плату всё готово, создаём пустой проект для de1-soc через
утилиту system_cd, добавляем все необходимые файлы, создаём модуль процессора и
памяти в верхнеуровневом файле и соединяем нужные входы и выходы, запускаем
процесс синтеза... получаем ошибку...</p>
<p>При выяснении причин ошибок отправляемся в файл
<code>cv32e40p_register_file_latch.sv</code> и видим следующее:</p>
<pre><code class="language-systemverilog">...

  if (FPU == 1 &amp;&amp; ZFINX == 0) begin
    // Floating point registers
    always_latch begin : latch_wdata_fp
      if (FPU == 1) begin
        for (l = 0; l &lt; NUM_FP_WORDS; l++) begin : w_WordIter
          if (~rst_n) mem_fp[l] = '0;
          else if (mem_clocks[l+NUM_WORDS] == 1'b1)
            mem_fp[l] = waddr_onehot_b_q[l+NUM_WORDS] ? wdata_b_q : wdata_a_q;
        end
      end
    end
  end
endmodule
</code></pre>
<p><code>FPU</code> и <code>ZFINX</code> являются задаваемыми параметрами, замысел конструкции понятен,
но он, вроде как, нарушает синтаксис verilog, который позволяет использовать
<code>if</code> только внутри цикла <code>always</code>.</p>
<p>Исправлять ошибки (ошибки ли это? может так и задумано) мы посчитали странным,
так как не до конца ясна микроархитектура процессора и замысел этих
конструкций, поэтому исследование этого процессора отложено на время, пока не
будет выяснено, что это значит и почему так было сделано.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="darkriscv"><a class="header" href="#darkriscv">DarkRISCV</a></h1>
<p><del>Реализован с нуля за одну ночь</del></p>
<ul>
<li><a href="https://github.com/darklife/darkriscv">GitHub</a></li>
<li>Отдельной документации нет</li>
</ul>
<h2 id="Обзор"><a class="header" href="#Обзор">Обзор</a></h2>
<p>DarkRISCV - Софт-процессор, написанный на Verilog, реализующий RV32I и RV32E. В
относительности небольших размеров код позволяет с меньшими трудностями
разобраться в ядре и модифицировать его. FPGA Proven, загружался на ПЛИС от
xilinx и некоторые от Altera (но, к сожалению, не на наши).</p>
<p>Некоторые возможности ядра:</p>
<ul>
<li>Нормально работает с GCC</li>
<li>Поддержка UART</li>
<li>Контроллер прерываний</li>
<li>Контроллер кэшэй</li>
<li>GPIO и таймер</li>
<li>Предсказатель ветвления</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cva6"><a class="header" href="#cva6">CVA6</a></h1>
<p>CVA6 - 64-разрядное ядро с 6-ступенчатым конвейером (Рис. 1). В данном
процессоре реализованы 3 уровня привилегий M, S, U для полной поддержки
Unix-подобных операционных систем. По данной причине основным назначением
процессора является запуск полноценной операционной системы. Отличительной
особенностью данной реализации является наличие 6 стадий конвейера в отличие от
классического конвейера с 5 стадиями.</p>
<p><img src="materials/reviews/CVA6/./cva6_scheme.png" alt="CVA6 Scheme" /></p>
<p>Еще одной особенностью является наличие PC Generation, который отвечает за
вычисление адреса следующей инструкции, а также за учёт ветвлений в данном
процессе. Он имеет специальные блоки BHT (Branch History Table), содержащий
историю “прыжков” PC, и BTB (Branch Target Buffer), который является буфером
ветвления. Также PC Generation на основе истории ветвлений направлен на
прогнозирование будущих ветвлений (Рис. 2).</p>
<p><img src="materials/reviews/CVA6/cva6_pc_gen.png" alt="CVA6 PC Gen" /></p>
<p>Также есть возможность декодировать сокращенные команды, которые занимают 16
бит, а не 32, как в классическом варианте.</p>
<p>Есть возможность работы с CSR инструкцией, при этом для работы с ней создан
отдельный буфер, так как инструкция CSR изменяет состояние архитектуры.</p>
<p>Кроме этого есть в данном процессоре есть возможность работы с CSR-инструкцией.
Для этого создан отдельный буфер ввиду того, что инструкция CSR изменяет
состояние архитектуры.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="picorv32"><a class="header" href="#picorv32">PicoRV32</a></h1>
<p>Это ядро мы уже кратко обозревали в одном из предыдущих отчётов, здесь
постараемся сделать более подробно.</p>
<h2 id="Описание"><a class="header" href="#Описание">Описание</a></h2>
<p>PicoRV32 - ядро разработанное YosysHQ (те же ребята, что делают парсер
verilog'а для OpenLane), может реализовывать архитектуры RV32E, RV32I, RV32IC,
RV32IM или RV32IMC.</p>
<p>Основные особенности:</p>
<ul>
<li>Компактное (750-2000 LUT на Xilinx)<sup class="footnote-reference"><a href="#lut">1</a></sup></li>
<li>Высокое значение максимальной частоты (250-400 МГц)</li>
<li>Опциональное IRQ<sup class="footnote-reference"><a href="#irq">2</a></sup></li>
</ul>
<div class="footnote-definition" id="lut"><sup class="footnote-definition-label">1</sup>
<p>~6000 на Cyclone</p>
</div>
<div class="footnote-definition" id="irq"><sup class="footnote-definition-label">2</sup>
<p>Не соответствует RISC-V ISA</p>
</div>
<h2 id="Некоторые-особенности"><a class="header" href="#Некоторые-особенности">Некоторые особенности</a></h2>
<p>В процессе изучения ядра было выявлены следующие особенности:</p>
<ul>
<li>Всё ядро реализованно в одном Verilog файле (что, возможно, не очень хорошо)</li>
<li>Вся документация в readme</li>
<li>Хорошо задокументированы параметры модулей, собственная реализация IRQ</li>
<li>Остальное задокументировано плохо (вводы/выводы модулей, внутренее
устройство)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Программирование"><a class="header" href="#Программирование">Программирование</a></h1>
<p>Тут такое дело, что для запуска программ шифромания/дешифрование их нужно для
начала сделать... Тут есть два пути, как добиться желаемого:</p>
<ul>
<li>Написать на ассемблере</li>
<li>Написать на C</li>
</ul>
<h2 id="Ассемблер"><a class="header" href="#Ассемблер">Ассемблер</a></h2>
<h4 id="pros"><a class="header" href="#pros">Pros</a></h4>
<ul>
<li>Это, скорее всего, заработает с меньшими затратами</li>
<li>Больший контроль над используемыми инструкциями</li>
</ul>
<h4 id="cons"><a class="header" href="#cons">Cons</a></h4>
<p><img src="materials/programing/./cringe.jpg" alt="Cringe" /></p>
<ul>
<li>Объёем работы для реализации большой</li>
<li>Труднее читать</li>
<li>Труднее отлаживать</li>
</ul>
<h4 id="decision"><a class="header" href="#decision">Decision</a></h4>
<p>Очень не хотелось бы идти по этому пути, желательно добиться работы через язык
программирования. В остальном, прибегать к ассемблеру только в отчаяном
положении, когда модифицировать компилятор и заставить работать программу
совсем не выходит.</p>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<h4 id="pros-1"><a class="header" href="#pros-1">Pros</a></h4>
<ul>
<li>Более высокоуровневая абстракция</li>
<li>Проще разрабатывать и читать</li>
<li>Больше возможностей для использования готовых компонентов</li>
</ul>
<h4 id="cons-1"><a class="header" href="#cons-1">Cons</a></h4>
<ul>
<li>Нужно модифицировать компилятор 🥶</li>
<li>Могут возникнуть трудности при использовании инструкций из расширений</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Введение-2"><a class="header" href="#Введение-2">Введение</a></h1>
<p>Здесь будет рассматриваться варианты написать нужные программы на
высокоуровневом языке (C), в том числе:</p>
<ul>
<li><a href="materials/programing/compiler/./inline_asm.html">Использование inline assembly</a></li>
<li>Модификация компилятора</li>
<li>Опыт других людей</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ассемблерные-вставки"><a class="header" href="#Ассемблерные-вставки">Ассемблерные вставки</a></h1>
<p>Изучая и обдумывая работу с микроконтроллерами мне пришла идея (вернее, я
согласился с идеей, прочитанной на стаке ранее, которую отвер изначально), что,
возможно, модификация компилятора не самый удачный подход к задаче, ведь мы
можем использовать inline assebmly, чтобы вызвать наши новые инструкции и
инкапсулировать взаимодействие с ними в библиотеку.</p>
<p>То есть нам даже не нужно добавлять название в набор инструкций компилятора, мы
можем просто вставлять какое-то (составленные самостоятельно) машинное слово и
исполнить его как инструкцию.</p>
<p><a href="https://stackoverflow.com/questions/19836327/change-instruction-set-in-gcc">Источник вдохновения</a></p>
<p>Пример:</p>
<pre><code class="language-c">int main() {
    asm __volatile__ (".byte 0x90\n");
    return 0;
}
</code></pre>
<h2 id="Плюсы"><a class="header" href="#Плюсы">Плюсы</a></h2>
<ul>
<li>Быстрота реализации</li>
<li>Возможность быстро проверить работоспособность</li>
<li>Гарантии того, что инструкции точно будут задействованы</li>
</ul>
<h2 id="Минусы"><a class="header" href="#Минусы">Минусы</a></h2>
<ul>
<li>Нужно будет написать библиотеку работы с новыми инструкциями</li>
<li>Нужно явно реализовать алгоритм шифрования с написанными функциями</li>
</ul>
<h2 id="Решение"><a class="header" href="#Решение">Решение</a></h2>
<p>Скорее всего реализовать сначала простой вариант - хорошая идей, можно
убедиться в работоспособности всего махенизма, далее, убедившись в работе
простого подхода, можно реализовать сложный с модификацией компилятора.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Модификация-компилятора-Под-вопросом"><a class="header" href="#Модификация-компилятора-Под-вопросом">Модификация компилятора (Под вопросом)</a></h1>
<h2 id="Список-компиляторов"><a class="header" href="#Список-компиляторов">Список компиляторов</a></h2>
<p>На данный момент я нашёл следующий компиляторы C, которые мы можем использовать
в нашей работе:</p>
<ul>
<li>GCC</li>
<li>LLVM</li>
<li>TinyCC</li>
</ul>
<h2 id="Полезные-ссылки-1"><a class="header" href="#Полезные-ссылки-1">Полезные ссылки</a></h2>
<p>Проекты и документация по работе с внутренней частью компилятора:</p>
<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gccint/">Документация по устройству GCC</a></li>
<li><a href="https://github.com/riscv/riscv-opcodes">RISC-V Opcodes</a></li>
<li><a href="https://github.com/TinyCC/tinycc">TinyCC github</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Введение-3"><a class="header" href="#Введение-3">Введение</a></h1>
<p>В этом разделе будет рассматриваться материалы по реализации косимуляции и
обмена данными компьютера с ПЛИС в процессе работы.</p>
<p>Самым перспективным подходом является использование передачи данных по UART.</p>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://habr.com/ru/articles/109395/">Статья по UART</a></li>
<li><a href="https://habr.com/ru/companies/ruvds/articles/578432/">Статья по программированию UART</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Отчёт-от-30102023"><a class="header" href="#Отчёт-от-30102023">Отчёт от 30.10.2023</a></h1>
<h2 id="О-чём"><a class="header" href="#О-чём">О чём?</a></h2>
<p>Рассмотрели список ядер по ссылке
<a href="https://github.com/riscvarchive/riscv-cores-list/blob/master/README.md">https://github.com/riscvarchive/riscv-cores-list/blob/master/README.md</a>.
Выбрали несколько ядер для первоочередного рассмотрения.</p>
<p>Критерии отбора:</p>
<ul>
<li>Открытая лицензия</li>
<li>Язык: Verilog или System Verilog</li>
</ul>
<h2 id="Результаты"><a class="header" href="#Результаты">Результаты</a></h2>
<p>Первым делом отфильтровали весь список по требованиям, представленным выше,
получили список из 19 ядер, удовлетворяющих этим требованиям:</p>
<div class="table-wrapper"><table><thead><tr><th>Название</th><th>Репозиторий</th></tr></thead><tbody>
<tr><td>CV32E40P</td><td><a href="https://github.com/openhwgroup/cv32e40p">https://github.com/openhwgroup/cv32e40p</a></td></tr>
<tr><td>Ibex (formerly Zero-riscy)</td><td><a href="https://github.com/lowRISC/ibex">https://github.com/lowRISC/ibex</a></td></tr>
<tr><td>CVA6</td><td><a href="https://github.com/openhwgroup/cva6">https://github.com/openhwgroup/cva6</a></td></tr>
<tr><td>OPenV/mriscv</td><td><a href="https://github.com/onchipuis/mriscv">https://github.com/onchipuis/mriscv</a></td></tr>
<tr><td>Roa Logic RV12</td><td><a href="https://github.com/roalogic/RV12">https://github.com/roalogic/RV12</a></td></tr>
<tr><td>SCR1</td><td><a href="https://github.com/syntacore/scr1">https://github.com/syntacore/scr1</a></td></tr>
<tr><td>Hummingbird E200</td><td><a href="https://github.com/SI-RISCV/e200_opensource">https://github.com/SI-RISCV/e200_opensource</a></td></tr>
<tr><td>PicoRV32</td><td><a href="https://github.com/cliffordwolf/picorv32">https://github.com/cliffordwolf/picorv32</a></td></tr>
<tr><td>SERV</td><td><a href="https://github.com/olofk/serv">https://github.com/olofk/serv</a></td></tr>
<tr><td>SweRV EH1</td><td><a href="https://github.com/chipsalliance/Cores-SweRV">https://github.com/chipsalliance/Cores-SweRV</a></td></tr>
<tr><td>SweRV EL2</td><td><a href="https://github.com/chipsalliance/Cores-SweRV-EL2">https://github.com/chipsalliance/Cores-SweRV-EL2</a></td></tr>
<tr><td>SweRV EH2</td><td><a href="https://github.com/chipsalliance/Cores-SweRV-EH2">https://github.com/chipsalliance/Cores-SweRV-EH2</a></td></tr>
<tr><td>biRISC-V</td><td><a href="https://github.com/ultraembedded/biriscv">https://github.com/ultraembedded/biriscv</a></td></tr>
<tr><td>DarkRISCV</td><td><a href="https://github.com/darklife/darkriscv">https://github.com/darklife/darkriscv</a></td></tr>
<tr><td>SSRV</td><td><a href="https://github.com/risclite/SuperScalar-RISCV-CPU">https://github.com/risclite/SuperScalar-RISCV-CPU</a></td></tr>
<tr><td>Tinyriscv</td><td><a href="https://github.com/liangkangnan/tinyriscv">https://github.com/liangkangnan/tinyriscv</a></td></tr>
<tr><td>RSD</td><td><a href="https://github.com/rsd-devel/rsd">https://github.com/rsd-devel/rsd</a></td></tr>
<tr><td>Kronos</td><td><a href="https://github.com/SonalPinto/kronos">https://github.com/SonalPinto/kronos</a></td></tr>
<tr><td>Steel</td><td><a href="https://github.com/rafaelcalcada/steel-core">https://github.com/rafaelcalcada/steel-core</a></td></tr>
</tbody></table>
</div>
<h2 id="Заинтересовавшие-ядра"><a class="header" href="#Заинтересовавшие-ядра">Заинтересовавшие ядра</a></h2>
<ul>
<li>SCR1</li>
<li>CVA6</li>
<li>PicoRV32</li>
</ul>
<h2 id="Что-дальше"><a class="header" href="#Что-дальше">Что дальше?</a></h2>
<p>Выберем три ядра и копнём глубже в их документацию, постараемся ознакомится с
микроархитектурой и устройством каждого из них, а также оценим их
функциональные возможности.</p>
<h2 id="cva6---первое-мнение"><a class="header" href="#cva6---первое-мнение">CVA6 - первое мнение</a></h2>
<p><img src="reports/2023-10-30/./cva6_overview.png" alt="CVA6" title="Схема процессора CVA6" /></p>
<p>CVA6 - процессорное ядро risc-v с 6-ступенчатым конвейером, имеет отдельный
сайт с документацией по использованию и устройству
(<a href="https://docs.openhwgroup.org/projects/cva6-user-manual/">https://docs.openhwgroup.org/projects/cva6-user-manual/</a>), для каждой стадии
есть отдельный блок документации, в целом, перые впечатления приятные,
документация выглядит досаточно подробной, а репозиторий имеет неплохую
активность.</p>
<h2 id="scr1---первое-мнение"><a class="header" href="#scr1---первое-мнение">SCR1 - первое мнение</a></h2>
<p><img src="reports/2023-10-30/./scr1_overview.png" alt="SCR1" title="Схема процессора SCR1" /></p>
<p><img src="reports/2023-10-30/./scr1_pipeline.png" alt="SCR1 Pipeline" title="Схема конвейера SCR1" /></p>
<p>Документация (<a href="https://github.com/syntacore/scr1/tree/master/docs">https://github.com/syntacore/scr1/tree/master/docs</a>) не выглядит
дружелюбной на первый взгляд, но углубившись лучше можно заметить, что
отдельный блоки описаны достаточно подробно, в том числе имеются временные
диаграммы.</p>
<h2 id="picorv32---первое-мнение"><a class="header" href="#picorv32---первое-мнение">PicoRV32 - первое мнение</a></h2>
<p><img src="reports/2023-10-30/./im_confus.jpg" alt="im confus" /></p>
<p>Изначально подавал большие надежды, но документация оставляет желать лучшего,
кроме README других заметок по архитектуре нет, но возможно мы ошибаемся и ещё
не нашли то, что нужно. Также следует отметить, что репозиторий не обновляется
уже как 2 года. Из интересного: всё описание ядра содержится в одном verilog
файле, несмотря на описанные выше недостатки, ознакомиться стоит.</p>
<h2 id="cva6---углубление"><a class="header" href="#cva6---углубление">CVA6 - углубление</a></h2>
<p>Особенностью данной реализации является наличие 6-ти стадий конвейера, в
отличие от классического конвейера с 5-ю стадиями.</p>
<p>PC Generation отвечает за вычисление адреса следующей инструкции, а также учёт
ветвлений в данном процессе. Имеет специальные блоки BHT (Branch History
Table), содержащий историю “прыжков” PC, и BTB (Branch Target Buffer) буфер
ветвления. Также PC Gen на основе истории ветвлений пытается предсказывать
грядущие ветвления.</p>
<p><img src="reports/2023-10-30/./cva6_pc_gen.png" alt="PC Gen" /></p>
<p>Также есть возможность декодировать сокращенные команды, которые занимают 16
бит, а не 32, как в классическом варианте.</p>
<p>Есть возможность работы с CSR инструкцией, при этом для работы с ней создан
отдельный буфер, так как инструкция CSR изменяет состояние архитектуры.</p>
<p>Обзор микроархитектуры проводился на основе приложенной документации
<a href="https://docs.openhwgroup.org/projects/cva6-user-manual/03_cva6_design/intro.html">https://docs.openhwgroup.org/projects/cva6-user-manual/03_cva6_design/intro.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Отчёт-от-13112023"><a class="header" href="#Отчёт-от-13112023">Отчёт от 13.11.2023</a></h1>
<h2 id="О-чём-1"><a class="header" href="#О-чём-1">О чём?</a></h2>
<p>Углубляемся в устройство процессоров перечисленных в прошлом отчёте, ищем
полезные для нас наработки на opencores.</p>
<h2 id="Результаты-1"><a class="header" href="#Результаты-1">Результаты</a></h2>
<h3 id="picorv32---углубление"><a class="header" href="#picorv32---углубление">PicoRV32 - углубление</a></h3>
<p>Сразу стоит отметить, что данное ядро является достаточно универсальным, так
как имеет много инструментов конфигурации под определенные задачи и требования.
Есть возможность отключения некоторого функционала для уменьшения размера ядра
или наоборот подключения для получения максимальной производительности.</p>
<p>PicoRV32 может быть сконфигурирован как ядро RV32E, RV32I, RV32IC, RV32IM или
RV32IMC и, при необходимости, содержит встроенный контроллер прерываний.</p>
<p>Этот процессор предназначен для использования в качестве вспомогательного
процессора в конструкциях FPGA и ASIC. Благодаря высокой максимальной частоте
он может быть интегрирован в большинство существующих конструкций без
пересечения тактовых частот. При работе на более низкой частоте он будет иметь
значительный временной провал и, таким образом, может быть добавлен в
конструкцию без ущерба для синхронизации.</p>
<p>Из особенностей можно выделить следующее:</p>
<ul>
<li>Небольшой (750-2000 LUT в архитектуре Xilinx 7-й серии)</li>
<li>Высокая максимальная частота (250-450 МГц на ПЛИС Xilinx 7-й серии)</li>
<li>Выбираемый интерфейс встроенной памяти или AXI4-Lite master</li>
<li>Дополнительная поддержка IRQ (с использованием простого пользовательского
ISA)</li>
<li>Дополнительный интерфейс сопроцессора</li>
</ul>
<p>Из интересных возможностей конфигурации можно выбирать между двухпортовой и
однопортовой реализацией регистрового файла. Первая обеспечивает лучшую
производительность, в то время как вторая приводит к уменьшению ядра.</p>
<p>Из сомнительных моментов можно выделить то, что функции обработки IRQ в
PicoRV32 не соответствуют спецификации привилегированного ISA RISC-V. Вместо
этого используется небольшой набор очень простых пользовательских инструкций
для реализации обработки IRQ с минимальными затратами на оборудование.</p>
<p>Обзор архитектуры приводился на основе описания репозитория:
<a href="https://github.com/YosysHQ/picorv32">https://github.com/YosysHQ/picorv32</a></p>
<h3 id="Алгоритмы-шифрования"><a class="header" href="#Алгоритмы-шифрования">Алгоритмы шифрования</a></h3>
<h4 id="aes-1"><a class="header" href="#aes-1">AES</a></h4>
<p>С этим алгоритмом никаких подводных камней, есть лишь одна реализация –
Rijndael, которую мы и будем изучать. Также смогли найти подходящие для нас
реализации на Verilog и С, <del>которые будем заимствовать</del> на которые можем
опираться.</p>
<p>Полезные ссылки:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a></li>
<li><a href="https://opencores.org/projects/tiny_aes">https://opencores.org/projects/tiny_aes</a></li>
<li><a href="https://github.com/kokke/tiny-AES-c">https://github.com/kokke/tiny-AES-c</a></li>
</ul>
<h4 id="sha-1"><a class="header" href="#sha-1">SHA</a></h4>
<p>Тут уже не так всё ясно, у него есть несколько реализаций – SHA-2 (разработан в
АНБ, наиболее распространён) и SHA-3 (он же Keccak, разработан не в АНБ) Нужно
отметить, что сертифицированная реализация SHA на verilog это SHA-3, но
спецификация RISC-V Crypto требует SHA-2… ладно :(</p>
<p>Поэтому ищем ресурсы по SHA-2:</p>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/SHA-2">https://ru.wikipedia.org/wiki/SHA-2</a></li>
<li><a href="https://opencores.org/projects/sha_core">https://opencores.org/projects/sha_core</a></li>
</ul>
<h4 id="tiny-aes---обзор"><a class="header" href="#tiny-aes---обзор">Tiny AES - обзор</a></h4>
<p>Одна из самых популярных реализаций алгоритма AES на Verilog, которая
сертифицирована opencores (<a href="https://opencores.org/projects/tiny_aes">https://opencores.org/projects/tiny_aes</a>).
Структура проекта достаточно проста для понимания, интересующий нас реализация
находится в разделе trunk/rtl, основными смысловыми блоками являются раунды
шифрования/дешифрования и расширения ключей, в дальнейшем эти блоки
используются в модулях, реализующих сам алгоритм.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Отчёт-от-20112023"><a class="header" href="#Отчёт-от-20112023">Отчёт от 20.11.2023</a></h1>
<h2 id="О-чём-2"><a class="header" href="#О-чём-2">О чём?</a></h2>
<p>Углбление в процессор CVA6 и обзор перспективного для нас процессора CV32E40P.</p>
<h2 id="Результат"><a class="header" href="#Результат">Результат</a></h2>
<p>После изучения CVA6 рассмотрели и его младшую редакцию – CV32E40P
(<a href="https://github.com/openhwgroup/cv32e40p">https://github.com/openhwgroup/cv32e40p</a>), обладает упрощённой
микроархитектурой, что в нашем случае может быть более удобным вариантом.</p>
<p>Также стоит отметь, что этот процессор не имеет встроенного instruction memory,
что также может быть полезно, если мы решим идти по пути косимуляции.</p>
<h3 id="cv32e40p-1"><a class="header" href="#cv32e40p-1">CV32E40P</a></h3>
<p><img src="reports/2023-11-20/./CV32E40P_Block_Diagram.png" alt="CV32E40P Diagram" title="Блок-схема процессора" /></p>
<p>CV32E40P (далее обозначается как Ешка) -- четырехстадийное 32-битное ядро
RISC-V и так далее (копоровать описание не стану), самое важное, что сразу
бросается в глаза: простота процессора и внешние интерфейсы.</p>
<p>Насчёт простоты, его микроархитектура очень похожа на schoolMIPS и уже по
диаграмме примерно ясны все основные блоки. Это большой плюс, так как <del>мы ещё
новички</del> меньше времени потребуется на вникание в структуру, а также будет
проще модифицировать. Ценой за эти удобства будет уменьшенный функционал, но,
возможно, нам будет достаточно и его.</p>
<!-- Кста, нужно создать ссылку на страницу по косимуляции когда её создадим -->
<p>Также стоит затронуть интерфейсы, у процессора, по всей видимости, нет блока
instruction memory, что может показаться недостатком, но это же мы можем
использовать и для своих нужд, если решим реализовать <a href="reports/2023-11-20/">косимуляцию</a>, то будет
проще создать отдельный модуль пямяти инструкций, который будет тягать эти
инструкции по UART.</p>
<h3 id="Формат-отчётов"><a class="header" href="#Формат-отчётов">Формат отчётов</a></h3>
<p>Открыли для себя новый инструмент -- mdbook, в котором продолжим вести наши
отчёты и накопленную вести базу знаний, удобный вещь, хочу сказать.</p>
<p>Также с началом работы здесь заметил, что не очень удобно хранить основную
информацию в отчётах, так как поиск и структурирование вызывают затруднение,
что создаст много проблем в дальнейшем при обращении к этой информации, поэтому
в дальнейшем работа будет направлена на расширение раздела "Материалы", а в
отчётах будут ссылки на новые и расширенные параграфы.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Отчёт-от-27112023"><a class="header" href="#Отчёт-от-27112023">Отчёт от 27.11.2023</a></h1>
<h2 id="Результаты-2"><a class="header" href="#Результаты-2">Результаты</a></h2>
<p>Читали в основном про программные средства полезные для нашей работы.</p>
<p>Рассмотрели (в ссылках подробности работы):</p>
<ul>
<li><a href="reports/2023-11-27/../../materials/programing/compiler/inline_asm.html">Inline assembly</a>, как
средство программирования с новыми инструкциями</li>
<li>Полезные статьи по устройству <a href="reports/2023-11-27/../../materials/cosim/intro.html">UART</a> и
способам работы с COM портами из программы</li>
</ul>
<h2 id="misc"><a class="header" href="#misc">Misc</a></h2>
<p>Лев на этой неделе заболел...<br />
Кирилл тоже заболел в начале следующей...</p>
<p><img src="reports/2023-11-27/./wolf_meme.jpg" alt="meme" title="Мы держимся" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Отчёт-от-11122023"><a class="header" href="#Отчёт-от-11122023">Отчёт от 11.12.2023</a></h1>
<h2 id="Введение-4"><a class="header" href="#Введение-4">Введение</a></h2>
<p>На этой неделе мы сделали более подробный обзор нескольких процессоров и постарались портировать один из них на DE1-SoC.</p>
<h2 id="Результаты-3"><a class="header" href="#Результаты-3">Результаты</a></h2>
<ul>
<li><a href="reports/2023-12-11/../../materials/reviews/CV32E40P/CV32E40P.html">Обзор CV32E40P</a></li>
<li><a href="reports/2023-12-11/../../materials/reviews/DarkRISCV/DarkRISCV.html">Обзор DarkRiscV</a></li>
<li><a href="reports/2023-12-11/../../materials/reviews/CVA6/CVA6.html">Обзор CVA6</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Отчёт-от-08012024"><a class="header" href="#Отчёт-от-08012024">Отчёт от 08.01.2024</a></h1>
<h2 id="О-чем"><a class="header" href="#О-чем">О чем?</a></h2>
<p>Углубление в процессор PicoRV32, создание пробного проекта с данным процессором
в Quartus.</p>
<h2 id="Результаты-4"><a class="header" href="#Результаты-4">Результаты</a></h2>
<p>Начали с клонирования репозитория с файлами процессора. Далее создали проект
picorv32 (пока без привязки к плате, так как еще полноценно не разобрались в
интерфейсах процессора, поэтому в разделе device выбрали случайную плату).</p>
<p>Добавили в проект следующую модули:</p>
<ul>
<li>picorv32.v (файл, в котором реализован сам процессор PicoRV32)</li>
<li>picosoc.v (верхнеуровневый файл системы на кристалле)</li>
<li>spimemio.v (файл модуля флеш памяти с интерфейсом SPI)</li>
<li>simpleuart.v (файл модуля для работы с UART)</li>
</ul>
<p>Далее выставили верхнеуровневый файл picosoc.v и запустили компиляцию проекта.
В итоге получили следующую ошибку:</p>
<p><img src="reports/2024-01-08/./error.jpg" alt="error" title="Ошибка компилляции" /></p>
<p>Нашли место, в котором происходит ошибка.</p>
<p><img src="reports/2024-01-08/./error_place.jpg" alt="error_place" title="Код с ошибкой" /></p>
<p>В результате данный проект требует определенный порядок компиляции файлов, но
так как в Quartus мы задаем Top-Level Entity, то порядок компиляции
определяется автоматически. Поэтому мы комментируем данную ошибку, повторяем
компиляцию и получаем успешно скомпилированный проект.</p>
<p><img src="reports/2024-01-08/./compile_result.jpg" alt="compile_result" title="Результат компиляции проекта" /></p>
<p>В итоге получаем:</p>
<ul>
<li>почти 6000 LUT, однако в документации заявлено 750-2000 LUT, но в архитектуре
Xilinx 7й серии</li>
<li>9783 регистров</li>
<li>2048 бит памяти</li>
</ul>
<h2 id="Прочее"><a class="header" href="#Прочее">Прочее</a></h2>
<p>Нашли интересную статью по смежному направлению, где реализовывали
криптографический SoC (на основе PicoRV32)
<a href="https://www.researchgate.net/publication/361843646_Design_of_an_Integrated_Cryptographic_SoC_Architecture_for_Resource-Constrained_Devices">https://www.researchgate.net/publication/361843646_Design_of_an_Integrated_Cryptographic_SoC_Architecture_for_Resource-Constrained_Devices</a></p>
<p>Всех С Новым Годом!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Отчёт-от-28012024"><a class="header" href="#Отчёт-от-28012024">Отчёт от 28.01.2024</a></h1>
<h2 id="Результаты-5"><a class="header" href="#Результаты-5">Результаты</a></h2>
<ul>
<li>Успешная симуляция работы программы на DarkRISCV</li>
<li>Успешный синтез SCR1 через подготовленный sdk</li>
<li>Пообщались с ребятами из Digital Design Community</li>
</ul>
<h2 id="darkriscv-1"><a class="header" href="#darkriscv-1">DarkRISCV</a></h2>
<p>В прошлый раз у нас получилось синтезировать ядро и загрузить его на плату, но
мы не могли проверить его работоспособность, поэтому на этой неделе мы решили
написать программу-счетчик (3 строки на ассемблере) и загрузить её вместо
заготовленной программы-загрузчика.</p>
<h3 id="Подготовка-к-загрузке"><a class="header" href="#Подготовка-к-загрузке">Подготовка к загрузке</a></h3>
<p>Для начала был добавлен вывод регистра x10 на семисегментные дисплей, был взят
модуль конвертации двоичного значения в формат семисегментного дисплея и
пременён для вывода, также был написан простой делитель тактов для уменьшения
частоты до наблюдаемого уровня.</p>
<p>Подключение выводов схемы к darkriscv:</p>
<pre><code class="language-verilog">wire clk;

wire [31:0] REG10;

clk_devider devider (
	CLOCK_50,
	clk,
);

darksocv soc (
	.XCLK     ( clk ),
	.XRES     ( GPIO_0[14] ),

	.UART_RXD (),
	.UART_TXD (),

	.LED      (),
	.DEBUG    (),

	.REG10 ( REG10 )
);

assign LEDR [9:0] = REG10 [9:0];

sm_hex_display hex0 (REG10[3:0], HEX0);
sm_hex_display hex1 (REG10[7:4], HEX1);
sm_hex_display hex2 (REG10[11:8], HEX2);
sm_hex_display hex3 (REG10[15:12], HEX3);
sm_hex_display hex4 (REG10[19:16], HEX4);
sm_hex_display hex5 (REG10[24:20], HEX5);
</code></pre>
<p>Модуль для деления тактов:</p>
<pre><code class="language-verilog">module clk_devider #(
    parameter dev = 20
)(
    input clkIn,
    output clkOut
);
    reg [31:0] cnt;
    always @(posedge clkIn)
        cnt = cnt + 1'b1;
    assign clkOut = cnt[dev];
endmodule
</code></pre>
<p>Модуль для конвертации:</p>
<pre><code class="language-verilog">module sm_hex_display
(
    input      [3:0] digit,
    output reg [6:0] seven_segments
);

    always @*
        case (digit)
        'h0: seven_segments = 'b1000000;  // g f e d c b a
        'h1: seven_segments = 'b1111001;
        'h2: seven_segments = 'b0100100;  //   --a--
        'h3: seven_segments = 'b0110000;  //  |     |
        'h4: seven_segments = 'b0011001;  //  f     b
        'h5: seven_segments = 'b0010010;  //  |     |
        'h6: seven_segments = 'b0000010;  //   --g--
        'h7: seven_segments = 'b1111000;  //  |     |
        'h8: seven_segments = 'b0000000;  //  e     c
        'h9: seven_segments = 'b0011000;  //  |     |
        'ha: seven_segments = 'b0001000;  //   --d-- 
        'hb: seven_segments = 'b0000011;
        'hc: seven_segments = 'b1000110;
        'hd: seven_segments = 'b0100001;
        'he: seven_segments = 'b0000110;
        'hf: seven_segments = 'b0001110;
        endcase

endmodule
</code></pre>
<p>Программа счётчик:</p>
<pre><code>.text

        add a0, zero, zero
loop:   addi a0, a0, 1
        j loop
</code></pre>
<h3 id="Симуляция-проекта"><a class="header" href="#Симуляция-проекта">Симуляция проекта</a></h3>
<p>Для симуляции нужно скомпилировать файлы проекта с помощью Icarus Verilog и
запустить выходной файл.</p>
<p><img src="reports/2024-01-22/./icarus_verilog.jpg" alt="IcarusVerilog" title="Результат симуляции в Icarus Verilog" /></p>
<p>Для рассмотрения вейвформ нужно выданный в результате симуляции vdc файл
передать в gtkwave.</p>
<p><img src="reports/2024-01-22/./gtkwave.jpg" alt="GTKWave" title="Результат симуляции в GTKWave" /></p>
<h3 id="Загрузка-на-плату-1"><a class="header" href="#Загрузка-на-плату-1">Загрузка на плату</a></h3>
<p>После успешной симуляции произвели загрузку проекта на плату, но к сожалению ни
на семисегментном дисплее, ни на диодах результат работы счетчика не появился.</p>
<p><img src="reports/2024-01-22/./load_result.jpg" alt="Result" title="Результат работы на плате" /></p>
<h2 id="scr1"><a class="header" href="#scr1">SCR1</a></h2>
<p>Постарались начать продвижение в изучении ядра SCR1 и обратили на него
ПРИСТАЛЬНОЕ ВНИМАНИЕ.</p>
<p>В репозитории scr1 есть ссылка на <a href="https://github.com/syntacore/scr1-sdk">SDK</a>
для загрузки на fpga с заготовленными программами, в числе подготовленных к
загрузке fpga есть и de10-lite, который имеется у нас в лаборатории, так что
всё хорошо. <em>Может быть есть смысл портировать на De1-SoC</em>.</p>
<p>Был клонирован репозиторий с SDK и была произведена попытка синтеза ядра:
<img src="reports/2024-01-22/./compile.jpg" alt="Compile" title="Результат компиляции" /></p>
<h2 id="Социализация"><a class="header" href="#Социализация">Социализация</a></h2>
<p>Задали интерезующие нас вопросы в Digital Design Community, в частности о SCR1
и общем подходе к изучению новых ядер.</p>
<p>На наш вопрос дал развёрнутый ответ Виктор Дашонок, специалист по развитию
образовательных программ YADRO, от него получили следующее:</p>
<ul>
<li>Ссылку на SCR1 SDK</li>
<li>Ссылку на задачник по программированию</li>
<li>Ссылку на список ядер от risc-v (Но не все ядра там свободные)</li>
<li>Предложение предоставить Early Access Kit</li>
<li>Обещание связать с кем-то из специалистов</li>
</ul>
<p>Также получили отческий совет от Юрия Панчула об общем подходе к изучению новых
ядер.</p>
<p>Благодарны за полученные ответы.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Отчёт-от-01042024"><a class="header" href="#Отчёт-от-01042024">Отчёт от 01.04.2024</a></h1>
<h2 id="О-чём-3"><a class="header" href="#О-чём-3">О чём?</a></h2>
<p><a href="https://github.com/leventium/schoolRISCV">schoolRISCV Fork</a></p>
<h2 id="Результаты-6"><a class="header" href="#Результаты-6">Результаты</a></h2>
<p>Разобраться с промышленными ядрами оказалось задачей неподъёмной для нас,
поэтому было принято решение начать с простого и взять schoolRISCV.</p>
<p>Его плюсы:</p>
<ul>
<li>Он достаточно прост</li>
<li>Его микроархитектура и устройство полностью ясны</li>
</ul>
<p>Минусы:</p>
<ul>
<li><strong>Не</strong> реализует RV32I</li>
</ul>
<p>Поставлена задача довести schoolRISCV до RV32I, на данный момент момент
реализованы 29 инструкций и осталось реализовать ещё 8 (ecall и ebreak, скорее
всего, будут пропущены).</p>
<p>Некоторые фрагменты реализации:</p>
<pre><code class="language-verilog">// sr_ram.v

module sr_ram #(
    parameter DEPTH = 256
) (
    input             clk,
    input      [31:0] data_addr,
    input      [31:0] write_data,
    input             we,
    input             sign,
    input             op_word, op_half, op_byte,
    output reg [31:0] read_data
);

    reg [7:0] mem [DEPTH-1:0];

    always @(posedge clk) begin
        if (we) begin
            case ({op_word, op_half, op_byte})
                3'b001: begin
                    mem[data_addr]   = write_data[ 7: 0];
                end
                3'b010: begin
                    mem[data_addr]   = write_data[ 7: 0];
                    mem[data_addr+1] = write_data[15: 8];
                end
                3'b100: begin
                    mem[data_addr]   = write_data[ 7: 0];
                    mem[data_addr+1] = write_data[15: 8];
                    mem[data_addr+2] = write_data[23:16];
                    mem[data_addr+3] = write_data[31:24];
                end
                default: read_data = '0;
            endcase
        end
    end

    always @(*) begin
        case ({op_word, op_half, op_byte})
            3'b001: begin
                read_data = {
                    { 24 { sign ? mem[data_addr][7] : 1'b0 } },
                    mem[data_addr]
                };
            end
            3'b010: begin
                read_data = {
                    { 16 { sign ? mem[data_addr+1][7] : 1'b0 } },
                    mem[data_addr+1],
                    mem[data_addr]
                };
            end
            3'b100: begin
                read_data = {
                    mem[data_addr+3],
                    mem[data_addr+2],
                    mem[data_addr+1],
                    mem[data_addr]
                };
            end
            default: read_data = 0;
        endcase
    end

endmodule
</code></pre>
<pre><code class="language-verilog">// sr_control.v

module sr_control
(
    input     [ 6:0] cmdOp,
    input     [ 2:0] cmdF3,
    input     [ 6:0] cmdF7,
    input            aluZero,
    output           pcSrc,     // pcBranch : pcPlus4
    output reg       regWrite,  // rf write enable
    output reg       aluSrc,    // immediate : rd2
    output reg       wdSrc,     // immU : execResult
    output reg       immPick,   // immS : immI
    output reg       memToReg,  // dmDataR : aluResult
    output reg       dmWe,      // data memory write enable
    output reg       dmSign,    // data memory signed read
    output reg [3:0] aluControl,
    output           dmOpByte,   // data memory operation mode
    output           dmOpHalf,
    output           dmOpWord
);
    reg          branch;
    reg          condZero;
    reg    [2:0] dmOpMode;

    assign {dmOpWord, dmOpHalf, dmOpByte} = dmOpMode;
    assign pcSrc = branch &amp; (aluZero == condZero);

    always @ (*) begin
        branch      = 1'b0;
        condZero    = 1'b0;
        regWrite    = 1'b0;
        aluSrc      = 1'b0;
        wdSrc       = 1'b0;
        immPick     = 1'b0;
        memToReg    = 1'b0;
        dmWe        = 1'b0;
        dmSign      = 1'b0;
        aluControl  = `ALU_ADD;
        dmOpMode    = `DM_WORD;

        casez( { cmdF7, cmdF3, cmdOp } )
            default: aluControl = `ALU_ADD;
            { `RVF7_ADD,  `RVF3_ADD,  `RVOP_ADD   } : begin
                regWrite = 1'b1;
                aluControl = `ALU_ADD;
            end
            { `RVF7_OR,   `RVF3_OR,   `RVOP_OR    } : begin
                regWrite = 1'b1;
                aluControl = `ALU_OR;
            end
            { `RVF7_SRL,  `RVF3_SRL,  `RVOP_SRL   } : begin
                regWrite = 1'b1;
                aluControl = `ALU_SRL;
            end
            { `RVF7_SLTU, `RVF3_SLTU, `RVOP_SLTU  } : begin
                regWrite = 1'b1;
                aluControl = `ALU_SLTU;
            end
            { `RVF7_SUB,  `RVF3_SUB,  `RVOP_SUB   } : begin
                regWrite = 1'b1;
                aluControl = `ALU_SUB;
            end
            { `RVF7_XOR,  `RVF3_XOR,  `RVOP_XOR   } : begin
                regWrite = 1'b1;
                aluControl = `ALU_XOR;
            end
            { `RVF7_AND,  `RVF3_AND,  `RVOP_AND   } : begin
                regWrite = 1'b1;
                aluControl = `ALU_AND;
            end
            { `RVF7_SLL,  `RVF3_SLL,  `RVOP_SLL   } : begin
                regWrite = 1'b1;
                aluControl = `ALU_SLL;
            end
            { `RVF7_SRA,  `RVF3_SRA,  `RVOP_SRA   } : begin
                regWrite = 1'b1;
                aluControl = `ALU_SRA;
            end
            { `RVF7_SLT,  `RVF3_SLT,  `RVOP_SLT   } : begin
                regWrite = 1'b1;
                aluControl = `ALU_SLT;
            end


            { `RVF7_ANY,  `RVF3_ADDI, `RVOP_ADDI  } : begin
                regWrite = 1'b1;
                aluSrc = 1'b1;
                aluControl = `ALU_ADD;
            end
            { `RVF7_ANY,  `RVF3_XORI, `RVOP_XORI  } : begin
                regWrite = 1'b1;
                aluSrc = 1'b1;
                aluControl = `ALU_XOR;
            end
            { `RVF7_ANY,  `RVF3_ORI,  `RVOP_ORI   } : begin
                regWrite = 1'b1;
                aluSrc = 1'b1;
                aluControl = `ALU_OR;
            end
            { `RVF7_ANY,  `RVF3_ANDI, `RVOP_ANDI  } : begin
                regWrite = 1'b1;
                aluSrc = 1'b1;
                aluControl = `ALU_AND;
            end
            { `RVF7_ANY,  `RVF3_SLLI, `RVOP_SLLI  } : begin
                regWrite = 1'b1;
                aluSrc = 1'b1;
                aluControl = `ALU_SLL;
            end
            { `RVF7_SLLI, `RVF3_SLLI, `RVOP_SLLI  } : begin
                regWrite = 1'b1;
                aluSrc = 1'b1;
                aluControl = `ALU_SLL;
            end
            { `RVF7_SRLI, `RVF3_SRLI, `RVOP_SRLI  } : begin
                regWrite = 1'b1;
                aluSrc = 1'b1;
                aluControl = `ALU_SRL;
            end
            { `RVF7_SRAI, `RVF3_SRAI, `RVOP_SRAI  } : begin
                regWrite = 1'b1;
                aluSrc = 1'b1;
                aluControl = `ALU_SRA;
            end
            { `RVF7_ANY,  `RVF3_SLTI, `RVOP_SLTI  } : begin
                regWrite = 1'b1;
                aluSrc = 1'b1;
                aluControl = `ALU_SLT;
            end
            { `RVF7_ANY,  `RVF3_SLTIU,`RVOP_SLTIU } : begin
                regWrite = 1'b1;
                aluSrc = 1'b1;
                aluControl = `ALU_SLTU;
            end


            { `RVF7_ANY,  `RVF3_ANY,  `RVOP_LUI   } : begin
                regWrite = 1'b1;
                wdSrc  = 1'b1;
            end


            { `RVF7_ANY,  `RVF3_BEQ,  `RVOP_BEQ   } : begin
                branch = 1'b1;
                condZero = 1'b1;
                aluControl = `ALU_SUB;
            end
            { `RVF7_ANY,  `RVF3_BNE,  `RVOP_BNE   } : begin
                branch = 1'b1;
                aluControl = `ALU_SUB;
            end


            // load / store instructions
            { `RVF7_ANY,  `RVF3_LB,   `RVOP_LOAD  } : begin
                memToReg = 1'b1;
                regWrite = 1'b1;
                aluSrc = 1'b1;
                dmOpMode = `DM_BYTE;
                dmSign = 1'b1;
            end
            { `RVF7_ANY,  `RVF3_LH,   `RVOP_LOAD  } : begin
                memToReg = 1'b1;
                regWrite = 1'b1;
                aluSrc = 1'b1;
                dmOpMode = `DM_HALF;
                dmSign = 1'b1;
            end
            { `RVF7_ANY,  `RVF3_LW,   `RVOP_LOAD  } : begin
                memToReg = 1'b1;
                regWrite = 1'b1;
                aluSrc = 1'b1;
                dmOpMode = `DM_WORD;
                dmSign = 1'b1;
            end
            { `RVF7_ANY,  `RVF3_LBU,  `RVOP_LOAD  } : begin
                memToReg = 1'b1;
                regWrite = 1'b1;
                aluSrc = 1'b1;
                dmOpMode = `DM_BYTE;
            end
            { `RVF7_ANY,  `RVF3_LHU,  `RVOP_LOAD  } : begin
                memToReg = 1'b1;
                regWrite = 1'b1;
                aluSrc = 1'b1;
                dmOpMode = `DM_HALF;
            end

            { `RVF7_ANY,  `RVF3_SB,   `RVOP_STORE } : begin
                dmWe = 1'b1;
                immPick = 1'b1;
                aluSrc = 1'b1;
                dmOpMode = `DM_BYTE;
            end
            { `RVF7_ANY,  `RVF3_SH,   `RVOP_STORE } : begin
                dmWe = 1'b1;
                immPick = 1'b1;
                aluSrc = 1'b1;
                dmOpMode = `DM_HALF;
            end
            { `RVF7_ANY,  `RVF3_SW,   `RVOP_STORE } : begin
                dmWe = 1'b1;
                immPick = 1'b1;
                aluSrc = 1'b1;
                dmOpMode = `DM_WORD;
            end
        endcase
    end
endmodule
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
