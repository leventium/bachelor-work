# Документация

**Авторы**: Фролов Кирилл, Мирошниченко Лев

## Структура репозитория

В ветке "rv32i" представлена версия ядра schoolRISCV, поддерживающее базовый набор инструкций RV32I, а в ветке "master" представлена версия расширенного ядра schoolRISCV с добавленным криптографическим модулем.

### Содержимое репозитория:
* **board** - папки с заготовленными проектами Quartus для различных плат ПЛИС (название папки соответсвует названию платы);
* **doc** - документы со спецификацией архитектуры RISCV;
* **install** - различные инструменты для работы с проектом, которые можно установить;
* **materials** - результаты моделирования, портирование, ресурсного и временного анализа базового и расширенного ядер schoolRISCV с программами, выполняющими криптографические операции;
* **program** - папки с разработанными программами, каждая папка называется аналогично содержащейся в ней программе (в каждой папке есть файл main.S или *.asm с текстом программы на языке ассемблер и файл program.hex с программой, представленной в машинном коде);
  * в ветке "master" отдельно представлена папка "native_crypto" с программами, использующими криптографические инструкции;
  * в ветке "rv32i" отдельно представлена пака "prog_crypto" с программами, выполняющими криптографические операции на базовых инструкциях набора RV32I;
* **src** - файлы с описанием ядра на языке Verilog;
* **submodules** - файлы с описанием криптографического модуля;
* **testbench** - файлы с описанием тестбенчей, разработанных для моделирования работы ядер

## Разработка программ

Для разработки программ потребуется использовать ассемблер RARS (`rars1_4.jar`
находится в директории `program/common`, для запуска использовать команду `java
-jar rars1_4.jar`).

Интерфейс RARS выглядит следующим образом:

![RARS Interface](./docs_img/rars_interface.png)

Рассмотрим ассемблирование программы на простом примере, для начала необходимо
разработать программу в текстовом редакторе:

![RARS Program](./docs_img/rars_program.png)

Для ассемблирования необходимо нажать кнопку "Assemble the current file":

![RARS Assemble](./docs_img/rars_assemble.png)

В результате программа перейдёт в следующее состояние:

![RARS Debugger](./docs_img/rars_debugger.png)

Также программу можно просимулировать и отладить непосредственно в RARS, для
этого необходимо нажать кнопку "Run" справа от кнопки "Assemble the current
file":

![RARS Simulate](./docs_img/rars_simulate.png)

Для дампа программы в шеснадцатеричный формат необходимо нажать кнопку "Dump
machine code":

![RARS Dump](./docs_img/rars_dump.png)

И выбрать формат "Hexadecimal Text":

![RARS Hexcode](./docs_img/rars_hexcode.png)

<div class="warning">
Важно:

RARS не умеет обрабатывать инструкции криптографического расширения, для их
использования нобходимо вставить инструкцию на машинном коде в результирующий
файл дампа.
</div>

## Симуляция ядра

Для симуляции ядра потребуется программа в формате `.hex`, её получение подробно
описано в разделе `Разработка программ`.

Создайте отдельную папку для Вашей программы в директории `program/` и
скопируйте в неё файл `Makefile` из любой другой директории в `program/`. Далее
добавьте в новую директорию прогрумму в формате `.hex`.

Для старта симуляции перейдите в созданную директорию и введите команду `make
icarus`. Результат будет, примерно, следующий (симуляция описывает процесс для
каждой инструкции):
![Sim Result](./docs_img/sim_result.png)

## Синтез ядра

### Для произведения синтеза ядра необходимо:
1. Предварительно установить приложение Quartus;
2. Перейти в папку board, а затем в папку с названием платы ПЛИС, на которую будет производится портирование;
3. Переименовать содержащиеся в папке файлы путем удаления символа "_" из расширения файла (Пример: *.qpf_ -> *.qpf);
4. Запустить программу Quatus и в верхнем меню программы нажать кнопку "File" и из выпавшего меню нажать кнопку "Open Project", после чего выбрать файл *.qpf в папке из пункта 2;

![Меню открытия проекта в Quartus](https://github.com/leventium/bachelor-work/assets/139256075/db2ffaf5-d772-496a-b28f-5cc53af29b63)


5. Убедиться, что все файлы из папки "src" добавлены в проекта, в обратном случае добавить все недостающие файлы путем нажатия кнопки "File" и нажатия кнопки "Open" из выпавшего меню. При выборе файлов в проводнике установить галочку в поле "Add file to current project";

![Меню добавления файлов в проект Quartus](https://github.com/leventium/bachelor-work/assets/139256075/e3308ccb-bad2-49ff-b407-6f60c259a238)

![Активное поле "Add file to current project"](https://github.com/leventium/bachelor-work/assets/139256075/f2a32739-4cad-45c7-8c07-3a61fa41ace6)

6. Выбрать программу, которую необходимо выполнить на ядре из папки "program" и скопировать файл program.hex в папку с проектом из пункта 2;
7. Выполнить синтез проекта, нажав кнопку "Start Compilation" в панели инструментов Quartus;

![Кнопка запуска синтеза](https://github.com/leventium/bachelor-work/assets/139256075/2a38df7e-b03d-4df6-9244-91acc33b0a93)

8. Дождаться завершения синтеза проекта;
9. В окне "Compilation Report" можно ознакомиться с результатами синтеза проекта и с числом использованный ресурсов.

![Compilation Report](https://github.com/leventium/bachelor-work/assets/139256075/051a0d57-b0fe-4f2e-9a11-1c27495ad70e)

### Для получения значения максимальной частоты, на которой способно работать ядро, необходимо:
1. Нажать из верхнего меню кнопку "Tools" и из выпавшего меню нажать кнопку "TimeQuest Timing Analyzer";

![Меню открытия временного анализа](https://github.com/leventium/bachelor-work/assets/139256075/9f892dd1-0160-4683-b849-7a687bf1b659)
 
2. В открывшемся окне в нижнем левом меню "Tasks" нажать кнопку "Report Fmax Summary";

![Меню открытия с расчетом максимальной частоты](https://github.com/leventium/bachelor-work/assets/139256075/3a725ec9-071d-46aa-a306-76425a860dab)

3. Ознакомиться с максимальной частотой, на которой способно работать ядро.

![Результат расчета максимальной частоты](https://github.com/leventium/bachelor-work/assets/139256075/c800ff6e-dc57-4948-ad57-ffee9c73dd01)

### Для загрузки проекта на плату ПЛИС необходимо:
1. Предварительно подключить плату ПЛИС к компьютеру;
2. Нажать кнопку "Programmer" в панели инструментов Quartus;

![Кнопка "Programmer"](https://github.com/leventium/bachelor-work/assets/139256075/bc44675b-6529-4c0c-a7b0-b1f008e02ef5)

3. Нажать кнопку "Hardware Setup" и выбрать устройство для программирования;

![Кнопку "Hardware Setup"](https://github.com/leventium/bachelor-work/assets/139256075/303e4bf0-416d-4f84-ab61-6cc391b0fc95)

4. Нажать кнопку "Start".


## Описание базового ядра

### Схема-описание ядра schoolRISCV, поддерживающего базовый набор инструкций RV32I:

![Схема-описание базового ядра](https://github.com/leventium/bachelor-work/assets/139256075/affaa990-ec17-4371-9420-70103b902f8d)

### Основные компоненты ядра:
* **Instruction Memory** - ROM-память, хранящая список испольняемых инструкций, представленных в машинном коде;
* **PC (Program Counter)** - программный счетчик, указывает на инструкцию, испольняемую на данной итерации;
* **Decode** - блок, декодирующий значение из Instruction Memory на основе спецификации RV32I;
* **Register File** - память, хранящая значения регистров;
  * **A1, A2, A3** - адресные порты;
  * **RD1, RD2** - порты чтения данных;
  * **WD3** - порт записи данных;
  * **WE3** - порт разрешения записи;
* **ALU** - блок, выполняющий арифметические и логические операции над входными операндами;
* **Data Memory** - память данных;
  * **A** - адресный порт;
  * **RD** - порт чтения данных;
  * **WD** - порт записи данных;
  * **WE** - порт разрешения записи;
  * **op_byte, op_half, op_word** - порты управления режимами чтения, записи (байт, полуслово, слово);
* **Control Unit** - управляющий блок, идентифицирует инструкции и в зависимости от исполняемой инструкции изменяет значения управляющих сигналов мультиплексоров, памяти регистров и памяти данных;
* **Логика перехода в нижней части схемы** - состоит из 2-х мультиплексоров и сумматора, рассчитывает следующее значение Program Counter.

## Описание расширенного ядра

### Схема-описание расширенного ядра:

![Core Extended](./docs_img/core_w_crypto.png)

### Описание изменений:

* **Crypto Module** - криптографический модуль на которое отправляются вычисления специальных инструкций
  * **crMode** - шина выбора криптографической операции
  * **crRes** - результат выполнения операции
* **Control Unit**
  * **pc_hold** - управляющий сигнал для программного счётчика, приостонавливающий его работу

<div class="warning">
Управляющий модуль больше не является только комбинационной логикой, был добавлен конечный автомат для корректирования работы схемы.
<div>
